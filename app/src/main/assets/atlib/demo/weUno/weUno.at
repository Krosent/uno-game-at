import /.at.lang.futures;
enableFutures(false);
import /.at.lang.totam;


def log(text) {
  Android.Log.i("weUno", text);
};

def makeWeUno(myID := /.at.support.util.randomNumberBetween(0, 125)) {
object: {
  def ts; // tuple space

  // myID := /.at.support.util.randomNumberBetween(1, 125)
  // Init this variable when device's player clicked connect button.
  def myReference;

  //def myID;
  def myName; // Let us suppose that each name is unique. (impossible to have two players with the same name).

  // By default all devices have id == 0.
  //We change our ID as soon as we get new device discovered.
  //If we discover new device -> we change our ID, unless we are already connected to the game.
  //def myID;

  // isConnected variable is our condition checker.
  // !! We will not change myID if isConnected is true.
  // --- TODO ---
  def isConnected := false;

  // Players who connected to the session. By default is zero.
  // Getter function getPlayersCounter().
  def playersCounter := 0;

  // Add new players to these lists (exclude player on this playing device).
  //HashMap of [id,Far Reference]
  // UPD: HashMap of [userID,[Username, Far Reference]]
  def otherPlayersHashMap := jlobby.java.util.HashMap.new();
  // jlobby.edu.vub.at.weuno.treemapat.new();

  //Array of far references, avoids iterating over hashmap
  def otherPlayers := [];

  def gui; // reference to Android UI object.

  deftype UnoPlayer;

  def init(newId){
    myID := newId;
  };

  //interface for android gui.
  def localInterface := object: {
    def connectPlayer(username) { // This method triggers on button click from Android.
        def playerTuple := tuple: ["UnoPlayer", myID, var: `player, var: `isConnected];

        ts.when: playerTuple in:{
          //system.println(“ “ + from + “ says: “ + content);
          isConnected := true;
          def connectedPlayerTuple := tuple: ["UnoPlayer", myID, player, isConnected];
          ts.inject: connectedPlayerTuple;
        };
    };

    def setID(id) { myID := id };

    def setName(newName) { myName := newName };

    //def setDeck(newDeck) { myDeck := newDeck };

    def setPlayersCounter(counter) {
        playersCounter := counter;

        // if players counter < 2 -> disable play button !!! Disabled by default

        if: (playersCounter >= 2) then: {
            // if players counter > 2 -> enable game button
            gui.enableGameButton();
        } else: {
            if: (playersCounter == 4) then: {
                // if players counter == 4 -> disable connect button
                gui.disableConnectButton();
            }
        };
    };

    // Update deck function. We update deck in TS.
    def setDeck(Deck) {
         def deckTuple := tuple: ["UnoDeck", var: `deck];
         def updatedDeckTuple := tuple: ["UnoDeck", Deck];
         ts.when: deckTuple in:{
            ts.inject: updatedDeckTuple;
         };
    };

    def playCard(Card) {
       def onlinePlayersPrototype := tuple: ["UnoPlayer", var: `id, var: `player, true];
       def onlinePlayersTuples := ts.rdg(onlinePlayersPrototype);

       // use disableConnectionDialog()
       onlinePlayersTuples.each: { |tuple| tuple.getField(3) <- playedCard(Card)};

    };


    def updateOPcards(Amount) {
        def playerTupleTemplate := tuple: ["UnoPlayer", myID, var: `player, var: `isConnected];
        def thisPlayerTuple := ts.rdp(playerTupleTemplate);
        def thisPlayerFarRef := thisPlayerTuple.getField(3);

        def keyIt := otherPlayersHashMap.keySet().iterator();
		def valIt := otherPlayersHashMap.values().iterator();


        while: { keyIt.hasNext() } do: {
            def key := keyIt.next();
            def value := valIt.next();

            if: (otherPlayersHashMap.size() == 1) then: {
                if: (myID < key) then: {
                    value <- setLeftPlayerCardCount(Amount);
                } else: {
                    value <- setRightPlayerCardCount(Amount);
                };

                log("Total number of players = 2");
            } else: {
                // TODO: Continue here tomorrow.
                if: (otherPlayersHashMap.size() == 2) then: {
                    log("Total number of players = 3");
                } else: {
                    log("Total number of players = 4");
                }
            }
        };

    };

    // Sort Implementation taken from documentation: http://soft.vub.ac.be/amop/at/tutorial/basic#control_flow_constructs
    // Based on quick sort algorithm.
    def sort(table, cmp := { |e1,e2| e1 < e2 }) {
      def quickSort(table, low, high) {
        def left := low;
        def right := high;
        def pivot := table[(left+right) /- 2];
        def save := nil;
        while: { left <= right } do: {
          while: { cmp(table[left], pivot) } do: {
            left := left + 1
          };
          while: { cmp(pivot, table[right]) } do: {
            right := right - 1
          };
          if: (left <= right) then: {
            // swap elements
            save := table[left];
            table[left] := table[right];
            table[right] := save;
            left := left + 1;
            right := right - 1;
          };
        };
        if: (low<right) then: { quickSort(table,low,right) };
        if: (high>left) then: { quickSort(table,left,high) };
        table;
      };
      quickSort(table, 1, table.length);
    };

    def nextID(table, currentID) {
        def nextID := -1;
        def notFound := true;
        def iterator := 1;

        while: { notFound } do: {
            if: (table[iterator] > currentID) then: {
                nextID := table[iterator];
                notFound := false;
            } else: {
                if: (iterator == table.length()) then: {
                    nextID := table[1];
                    notFound := false;
                }
            };
            iterator := iterator + 1;
        };

        nextID;
    };

    def prevID(table, currentID) {
        def iterator := table.length();
         def notFound := true;
        def predID := -1;
        // Use this method only with sorted table.
        while: { notFound } do: {
            if: (table[iterator] < currentID) then: {
                if: (iterator == 1) then: {
                    predID := table[table.length()];
                    notFound := false;
                } else: {
                    predID := table[iterator];
                    notFound := false;
                };
            };
            iterator := iterator - 1;
        };

        if: (predID == -1) then: { predID := table[table.length()] };

        predID;
    };


    def nextPlayer() {
        def unoGameStateProto := tuple: ["UnoGameState", var: `currentPlayerID, var: `moveDirection, var: `isGameEnded];
        def gameState := ts.rdp(unoGameStateProto);
        def nextPlayerID := myID; // In the begining we set it to our id, since we need to find higher value.
        def keyIt := otherPlayersHashMap.keySet().iterator();
        def valIt := otherPlayersHashMap.values().iterator();

        def keysTable := otherPlayersHashMap.keySet().toArray();


        // TODO: MOVE THIS PART OF CODE to sortTable/1 method.
        def sortedKeysTable := sort(keysTable);
        nextPlayerID := nextID(sortedKeysTable, myID);
        log("Player next id: " + nextPlayerID);

        //def prevPlayerID := prevID(sortedKeysTable, myID);
        //log("Player prev id: " + prevPlayerID);

        if: (gameState.getField(3) == "Forward") then: {
            while: { keyIt.hasNext() } do: {
                def key := keyIt.next();
                def value := valIt.next();
            };
        } else: {
             // Next Player should be a player whom ID is lower than current player, but not lower than others.
            while: { keyIt.hasNext() } do: {
                def key := keyIt.next();
                def value := valIt.next();

                if: (key < myID) then: {
                    if: (nextPlayerID > key) then: { nextPlayerID := key };
                };
            };
        };

        // Fetch Player
        def playerTupleTemplate := tuple: ["UnoPlayer", nextPlayerID, var: `player, var: `isConnected];
        def playerTuple := ts.rdp(playerTupleTemplate);
        def playerFarRef := playerTuple.getField(3);
        playerFarRef <- playTurn();
    };


    def initializeGame(Deck) {
        // Deck tuple in format ["UnoDeck", var: `deck]
        def deckTuple := tuple: ["UnoDeck", Deck];
        ts.inject: deckTuple;

        def onlinePlayersPrototype := tuple: ["UnoPlayer", var: `id, var: `player, true];
        def onlinePlayersTuples := ts.rdg(onlinePlayersPrototype);

        // use disableConnectionDialog()
        onlinePlayersTuples.each: { |tuple| tuple.getField(3) <- disableConnectionDialog()};

        // set start game state tuple
        def unoGameState := tuple: ["UnoGameState", myID, "Forward", false];
        ts.inject: unoGameState;
    };

    def initializeRelations() {
        // TODO: update pred on other devices
        // join(UserID, FarRef);
        otherPlayers.each: { |pl| pl <- join(myID, remoteInterface); };
    };

    def askDrawCards(Num, WhoToDrawID) {
        def usr := otherPlayersHashMap.getPlayerFarRef(WhoToDrawID);
        usr <- drawCards(Num)
    };

    // This function is used to ask other players to draw cards instantly.
    def drawCards(Num) {
        //gui.drawCards(Num);
        //otherPlayers.each: { |pl| pl <- drawCards(Num) };
        // TODO---
        // We start to ask a draw from succ player (the next player)


        //succ[2] <- drawCards(Num);
    };


    def drawedCards(NumberOfCards, Deck) {
        myReference := remoteInterface;
        setDeck(Deck);
        otherPlayers.each: { |pl| pl <- drawedCards(NumberOfCards, Deck, myReference) };
    };

    def getId() {
        myID;
    };


    def getPlayersCounter() { playersCounter };
  };

  //interface for remote painters.
  def remoteInterface := object: {

    //def sendReferenceToGUI() {}
    def receiveTestMessageFromAnother() { log("HEY FROM OUTSIDE"); }; // Удалить позже

    // Name Getter
    def getName() {
        myName;
    };

    // ID Getter
    def getID() {
        myID;
    };


    def initializeGame(Deck) {
        myDeck := Deck;
        // Sync deck
        gui.updateDeck(Deck);
        gui.disableConnectionDialog();
        gui.setGameState();

        gui.setLeftPlayerCardCount(0);
        gui.setTopPlayerCardCount(0);
        gui.setRightPlayerCardCount(0);
    };

    def disableConnectionDialog() {
        gui.disableConnectionDialog();
    };

    def drawCards(NumToDraw) {
        gui.drawCards(NumToDraw);
        succ[2];

        //succ[2] <- drawCards(NumToDraw);

        // If you have no successor then stop
        //if: ((succ[2] == self)) then: { log("End of point. No succ: " + succ[2])  } else: { succ[2] <- drawCards(NumToDraw) };
        //if: ((succ[2] == self).not()) then: { succ[2] <- drawCards(NumToDraw); log("I am: " + succ[2]) } else: { log("Vsyo: " + succ[2]) };
    };

    def updateDeck(Deck) {
        gui.updateDeck(Deck);
    };

    def playedCard(Card) {
        log("Color: " + Card);
        log("Action: " + Card[1]);

        def card := jlobby.edu.vub.at.weuno.Card.new(Card[1], Card[2], true);
        gui.playCard(card);
    };

    def setTopPlayerCardCount(n) {
        gui.setTopPlayerCardCount(n);
    };

    def setLeftPlayerCardCount(n) {
        gui.setLeftPlayerCardCount(n);
    };

    def setRightPlayerCardCount(n) {
        gui.setRightPlayerCardCount(n);
    };

    def playTurn() {
        gui.playTurn();
    };

    def drawedCards(NumberOfCards, Deck, SenderFarRef) {
        // Find id of the players from hash map of players.
        //gui.getPlayerIdFromHMList(otherPlayersHashMap, SenderFarRef);
        def opponentID := otherPlayersHashMap.getPlayerId(SenderFarRef);

        myDeck := Deck;

        // TODO

        gui.updateDeck(Deck);

        if:(opponentID == 0) then: {
            if: (opponentID == myID-1) then: {
                        gui.setRightPlayerCardCount(NumberOfCards);
                     } else: {
                        if:(opponentID == myID+1) then: {
                            gui.setLeftPlayerCardCount(NumberOfCards);
                        } else: {
                            gui.setTopPlayerCardCount(NumberOfCards);
                        };
                     };
        } else: {
            if: (opponentID == myID+1) then: {
                        gui.setLeftPlayerCardCount(NumberOfCards);
                     } else: {
                        if:(opponentID == myID-1) then: {
                            gui.setRightPlayerCardCount(NumberOfCards);
                        } else: {
                            gui.setTopPlayerCardCount(NumberOfCards);
                        };
                     };
        };
    };

    def goOnline() {
        // setup peer-to-peer service discovery
        network.online();

        ts := makeTupleSpace();
        ts.goOnline(); // start exchanging public tuples

        // Announce myself

        def selfTuple := tuple: ["UnoPlayer", myID, self, isConnected];
        log("MYSELF: " + myID);

        ts.inject: selfTuple;

        def playerTuple := tuple: ["UnoPlayer", var: `id, var: `player, var: `isConnected];
        ts.whenever: playerTuple read: {
             if: (!otherPlayers.contains(player)) then: {
                otherPlayers := otherPlayers + [player];

             };

             // Update gamers counter UI
             def onlinePlayersPrototype := tuple: ["UnoPlayer", var: `id, var: `player, true];
             def onlinePlayersTuples := ts.rdg(onlinePlayersPrototype);
             if: (onlinePlayersTuples.length > 0) then: {
                log("online Players Tuples: " + onlinePlayersTuples);
                gui.updateConnectedGamersCounter(onlinePlayersTuples.length);

                if: (onlinePlayersTuples.length != playersCounter) then: {
                    localInterface.setPlayersCounter(onlinePlayersTuples.length);
                };
             };

             if: (isConnected) then: {
                if: (!otherPlayersHashMap.containsKey(id)) then: {
                    if: (id != myID) then: { otherPlayersHashMap.put(id, player) }
                }
             };
        };

        // State Game Listener
        def unoGameStateProto := tuple: ["UnoGameState", var: `currentPlayerID, var: `moveDirection, var: `isGameEnded];
        ts.whenever: unoGameStateProto read: {
            log("Game state has been updated!");
        };


        def deckTuple := tuple: ["UnoDeck", var: `deck];
        ts.whenever: deckTuple read: {
            gui.setDeck(deck);
        };
    };

  goOnline();
  log("Hallo Android!");

  // example symbiosis
  gui := Android.parent.registerAtApplication(localInterface);
  Android.parent.topUnoAnimation();

  }; //end-remoteInterface
};

};

network.online;
self;