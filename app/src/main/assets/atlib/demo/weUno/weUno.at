import /.at.lang.futures;
enableFutures(false);
import /.at.lang.totam;


def log(text) {
  Android.Log.i("weUno", text);
};

def makeWeUno(myID := /.at.support.util.randomNumberBetween(0, 125)) {
object: {
  def ts; // tuple space

  // myID := /.at.support.util.randomNumberBetween(1, 125)
  // Init this variable when device's player clicked connect button.
  def myReference;

  //def myID;
  def myName; // Let us suppose that each name is unique. (impossible to have two players with the same name).

  // By default all devices have id == 0.
  //We change our ID as soon as we get new device discovered.
  //If we discover new device -> we change our ID, unless we are already connected to the game.
  //def myID;

  // isConnected variable is our condition checker.
  // !! We will not change myID if isConnected is true.
  // --- TODO ---
  def isConnected := false;

  // Players who connected to the session. By default is zero.
  // Getter function getPlayersCounter().
  def playersCounter := 0;

  // Add new players to these lists (exclude player on this playing device).
  //HashMap of [id,Far Reference]
  // UPD: HashMap of [userID,[Username, Far Reference]]
  def otherPlayersHashMap := jlobby.edu.vub.at.weuno.OrderedHashMap.new();

  //Array of far references, avoids iterating over hashmap
  def otherPlayers := [];

  def gui; // reference to Android UI object.

  deftype UnoPlayer;

  def init(newId){
    myID := newId;
  };

  //interface for android gui.
  def localInterface := object: {
    def connectPlayer(username) { // This method triggers on button click from Android.
        def playerTuple := tuple: ["UnoPlayer", myID, var: `player, var: `isConnected];

        ts.when: playerTuple in:{
          //system.println(“ “ + from + “ says: “ + content);
          isConnected := true;
          def connectedPlayerTuple := tuple: ["UnoPlayer", myID, player, isConnected];
          ts.inject: connectedPlayerTuple;
        };
    };

    def setID(id) { myID := id };

    def setName(newName) { myName := newName };

    //def setDeck(newDeck) { myDeck := newDeck };

    def setPlayersCounter(counter) {
        playersCounter := counter;

        // if players counter < 2 -> disable play button !!! Disabled by default

        if: (playersCounter >= 2) then: {
            // if players counter > 2 -> enable game button
            gui.enableGameButton();
        } else: {
            if: (playersCounter == 4) then: {
                // if players counter == 4 -> disable connect button
                gui.disableConnectButton();
            }
        };
    };

    def initializeGame(Deck) {
        // Deck tuple in format ["UnoDeck", var: `deck]
        def deckTuple := tuple: ["UnoDeck", Deck];
        ts.inject: deckTuple;

        //  setDeck(Deck);
        // Sync deck on other devices.
        //  otherPlayers.each: { |pl| pl <- initializeGame(Deck) };
    };

    def initializeRelations() {
        // TODO: update pred on other devices
        // join(UserID, FarRef);
        otherPlayers.each: { |pl| pl <- join(myID, remoteInterface); };
    };

    def askDrawCards(Num, WhoToDrawID) {
        def usr := otherPlayersHashMap.getPlayerFarRef(WhoToDrawID);
        usr <- drawCards(Num)
    };

    // This function is used to ask other players to draw cards instantly.
    def drawCards(Num) {
        //gui.drawCards(Num);
        //otherPlayers.each: { |pl| pl <- drawCards(Num) };
        // TODO---
        // We start to ask a draw from succ player (the next player)


        //succ[2] <- drawCards(Num);
    };


    def drawedCards(NumberOfCards, Deck) {
        myReference := remoteInterface;
        setDeck(Deck);
        otherPlayers.each: { |pl| pl <- drawedCards(NumberOfCards, Deck, myReference) };
    };

    def getId() {
        myID;
    };


    def getPlayersCounter() { playersCounter };

    def nextPlayer() {
        // Next Player is id + 1, unless id == size, then id == 0;
    };
  };

  //interface for remote painters.
  def remoteInterface := object: {

    //def sendReferenceToGUI() {}
    def receiveTestMessageFromAnother() { log("HEY FROM OUTSIDE"); }; // Удалить позже

    // Name Getter
    def getName() {
        myName;
    };

    // ID Getter
    def getID() {
        myID;
    };


    def initializeGame(Deck) {
        myDeck := Deck;
        // Sync deck
        gui.updateDeck(Deck);
        gui.disableConnectionDialog();
        gui.setGameState();

        gui.setLeftPlayerCardCount(0);
        gui.setTopPlayerCardCount(0);
        gui.setRightPlayerCardCount(0);
    };

    def drawCards(NumToDraw) {
        gui.drawCards(NumToDraw);
        succ[2];

        //succ[2] <- drawCards(NumToDraw);

        // If you have no successor then stop
        //if: ((succ[2] == self)) then: { log("End of point. No succ: " + succ[2])  } else: { succ[2] <- drawCards(NumToDraw) };
        //if: ((succ[2] == self).not()) then: { succ[2] <- drawCards(NumToDraw); log("I am: " + succ[2]) } else: { log("Vsyo: " + succ[2]) };
    };

    def updateDeck(Deck) {
        gui.updateDeck(Deck);
    };

    def drawedCards(NumberOfCards, Deck, SenderFarRef) {
        // Find id of the players from hash map of players.
        //gui.getPlayerIdFromHMList(otherPlayersHashMap, SenderFarRef);
        def opponentID := otherPlayersHashMap.getPlayerId(SenderFarRef);

        myDeck := Deck;

        // TODO

        gui.updateDeck(Deck);

        if:(opponentID == 0) then: {
            if: (opponentID == myID-1) then: {
                        gui.setRightPlayerCardCount(NumberOfCards);
                     } else: {
                        if:(opponentID == myID+1) then: {
                            gui.setLeftPlayerCardCount(NumberOfCards);
                        } else: {
                            gui.setTopPlayerCardCount(NumberOfCards);
                        };
                     };
        } else: {
            if: (opponentID == myID+1) then: {
                        gui.setLeftPlayerCardCount(NumberOfCards);
                     } else: {
                        if:(opponentID == myID-1) then: {
                            gui.setRightPlayerCardCount(NumberOfCards);
                        } else: {
                            gui.setTopPlayerCardCount(NumberOfCards);
                        };
                     };
        };
    };

    def goOnline() {
        // setup peer-to-peer service discovery
        network.online();

        ts := makeTupleSpace();
        ts.goOnline(); // start exchanging public tuples

        // Announce myself
        def selfTuple := tuple: ["UnoPlayer", myID, self, isConnected];
        ts.inject: selfTuple;

        def playerTuple := tuple: ["UnoPlayer", var: `id, var: `player, var: `isConnected];
        ts.whenever: playerTuple read: {
             if: (!otherPlayers.contains(player)) then: {
                otherPlayers := otherPlayers + [player];

             };

             // Update gamers counter UI
             def onlinePlayersPrototype := tuple: ["UnoPlayer", var: `id, var: `player, true];
             def onlinePlayersTuples := ts.rdg(onlinePlayersPrototype);
             if: (onlinePlayersTuples.length > 0) then: {
                log("online Players Tuples: " + onlinePlayersTuples);
                gui.updateConnectedGamersCounter(onlinePlayersTuples.length);
             };

             if: (isConnected) then: {
                log("Inside -is connected- conditional: " + id + " | " + "Player: " + player);
                //localInterface.setPlayersCounter(playersCounter+1);
                //gui.updateConnectedGamersCounter(playersCounter);


                if: (!otherPlayersHashMap.containsKey(id)) then: {
                    otherPlayersHashMap.put(id, player);
                };
             };

        };

        def deckTuple := tuple: ["UnoDeck", var: `deck];
        ts.whenever: deckTuple read: {
            gui.setDeck(deck);
        };
    };

  goOnline();
  log("Hallo Android!");

  // example symbiosis
  gui := Android.parent.registerAtApplication(localInterface);
  Android.parent.topUnoAnimation();

  }; //end-remoteInterface
};

};

network.online;
self;